# Проверка ruff и mypy для нового кода

## Алгоритм проверки:
1) скрипт запускает проверку для всего кода по ruff и mypy
2) получает изменения, внесённые в текущей ветке
3) находит пересечения изменённого кода и найденных ошибок по имени файла и изменённым строкам

Линтинг диффа нужен для больших существующих проектов, чтобы не фиксить весь файл на 1к строк целиком, а чтобы новый код проверялся по кодстайлу и требованиям линтеров

Такая проверка ускоряет разработку (можно добавить в CI/CD): разработчик видит ошибки только в своих изменениях, а не в легаси-коде.

## Установка
Для работы необходимо установить ruff и mypy
```shell
poetry install
```
или
```shell
pip install ruff mypy
```

## Env
Для локальной проверки и запуска git команд необходимо задать env-переменные
```text
APP_DIR='/home/user/projects/slk'
IS_LOCAL_LINTER_CHECK=true
```

## Запуск скрипта проверки
1. Запуск напрямую
```shell
./linter/run_analyze.sh
```
2. С использованием makefile
```shell
make lint
```

## Добавление новых правил
Для добавления новых линтеров нужно реализовать новый ```ReportParser``` и добавить его в список парсеров в ```linter_parser_classes```. 
Преимущество приложения в том, что можно добавлять кастомные правила, которые не отследить линтером

## Codestyle

#### 1. Форматирование

Длина строки: 120 символов
Кавычки: Одинарные (') для строк, кроме случаев, когда внутри строки есть одинарные кавычки

Для форматирования строк предпочтительны f-строки

Отступы: 4 пробела (включая отступы в объявлении функций)

```python
def my_method(
    self,
    first_var: int,
    second_var: Foo,
    third_var: Bar | None,
) -> int:
  ...
```


#### 2. Naming

Классы: PascalCase

```python
class UserProfile: ...
```
Функции/переменные: snake_case

```python
def calculate_total(): ...
user_count = 42
```
Константы: UPPER_SNAKE_CASE
```python
MAX_RETRIES = 3
```
#### 3. Аннотации типов
Обязательны для всех новых функций
```python
def greet(name: str) -> str:
    return f'Hello, {name}'
```
Generic-типы должны быть явными, использовать встроенные generic-типы вместо typing (list вместо typing.List)
```python
items: list[str] = ['a', 'b']
stats: dict[str, int] = {'views': 100}
Optional: Используйте | None
```

Union: Заменяйте на |
```python
def find_user(id: int) -> str | None: ...
def parse(value: str | int) -> float: ...
```
Избегайте Any



#### 4. Импорты
Группировка:

1) Стандартная библиотека
2) Сторонние библиотеки
3) Локальные модули

Используем абсолютные импорты.

Сортировка через isort.



#### 5. Исключения
Всегда указывайте тип исключения (Не просто except: и не except Exception):
```python
try:
    risky_call()
except ValueError as e:  # Не просто except: и не except Exception
    logger.error(e)
```
Используйте встроенные классы исключений, когда это имеет смысл

Минимизируйте объем кода в блоке try/ except

В идеале в try должно быть 1/2 строки. В конструкции не должно быть лишнего кода



#### 6. Trailing comma для многострочных коллекций
При этом не обязательно делать все коллекции многострочными, если они помещаются в одну строку

Для примера с запятой для многострочных списков
```python
colors = [
    'red',
    'green',
    'blue',  # Запятая обязательна
]

# но нужно так, если помещается

colors = ['red', 'green', 'blue']
```

#### 7. Формат переносов в функции

Если комбинация имени функции, последнего параметра и возвращаемого типа слишком длинная, сделайте отступ в 4 в новой строке. При использовании переносов строк предпочтительнее размещать каждый параметр и возвращаемый тип на отдельных строках и выравнивать закрывающую скобку с def:

```python
def my_method(
    self,
    other_arg: MyLongType | None,
) -> tuple[MyLongType1, MyLongType1]:
  ...
```


#### 8. Игнорируемые правила
assert разрешен (игнорируется "S101"), но только в тестах.
Табы разрешены (игнорируется "W191"), но лучше использовать пробелы.
Разрешён raise без from (игнорируется "B904")
